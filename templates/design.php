<h3>Overall Vision</h3>
<p>I&rsquo;ve always resented having to exchange email after email after email with people before I even meet them &mdash; it can be hard to begin a business meeting when your last ten communications have started, &ldquo;I&rsquo;m free from 10 am to 2:30 pm on Saturdays through Wednesdays, but not from 11 to 12:20 on Monday, or from 2 on on Tuesday&hellip;&rdquo; Google Calendar, conversely, helps me keep my life organized and free of conflicts. Thus, I figured that combining the two would solve a problem that I &mdash; and many other people &mdash; have all too often.</p>
<h3>Structure</h3>
<p>I knew I would need to use Google&rsquo;s API libraries to access Calendar data, so I decided to implement a user system which took advantage of the wonderful Google+ authentication methods. I began with simple code from pset8 (including the functions query() and apologize()), including a similar database, and integrated the Google API in from there. The diagram below illustrates the models, views, and controllers that make up my website.</p>
<h3>Styling</h3>
<p>I think one of the most important parts of a product can be its brand &mdash; even early iterations of Facebook had the characteristic blue-and-white color scheme, for example. I settled for a simple green-to-blue gradient for my logo, and integrated it throughout (try highlighting this text, for example!) To simplify the appearance of pages, I relied on images and hover text to convey certain information; thanks to the &ldquo;title&rdquo; attribute, you can hover over someone&rsquo;s name and see their email!</p>
<h3>Scheduling</h3>
<p>This is the heart of the website, but finding out how to do it wasn&rsquo;t as intuitive as I expected. Google Calendar presents its information in the form of events during which the user is busy. For example, if a user has an event from 1 pm to 3 pm and an event from 3:30 to 4:30, the following will describe the structure Google returns:</p>
<p>Thus, finding times during which no users are busy is more difficult than it may seem. At first I looked up scheduling algorithms, but then I realized that simpler was better for this. The diagram below describes the system used. At its simplest, it consists of three steps: identifying how many people are busy in each time interval, determining which time intervals should be considered based on user input, and then finding the best time interval for the entire group.</p>

